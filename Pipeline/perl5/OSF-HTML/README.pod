=encoding utf-8

=head1 NAME

HTML::Inspect - Inspect a HTML document

=head1 SYNOPSIS

    my $html         = slurp("t/data/collectMeta.html");
    my $inspector    = HTML::Inspect->new(request_uri => 'http://example.com/doc', html_ref => \$html);
    my $collectedMeta = $inspector->collectMeta();
    # $collectedMeta is:
    #{
    #    charset      => 'utf-8',
    #    name         => {
    #        Алабала => 'ница',
    #        generator => "Хей, гиди Ванчо",
    #        description => 'The Open Graph protocol enables...'
    #    },
    #    'http-equiv' => {
    #        'content-type' => 'text/html;charset=utf-8',
    #        refresh => '3;url=https://www.mozilla.org'
    #    }
    #};

=head1 DESCRIPTION

HTML::Inspect uses L<XML::LibXML> to parse a document as fast as possible and
returns different logical parts of it into self explanatory structures of data,
which can further be used for document analisys as part of a bigger pipeline.
See C<t/*.t> files for examples of use and returned results.

=head1 Constructors

=head2 new

    my $self = $class->new(%options)

Arguments: C<request_uri> and C<html_ref>. C<request_uri> is an absolute url as
a string or an L<URI> instance. C<html_ref> is areference to the valid HTML
string. Both argunebts are mandatory.

=head1 Accessors

=head2 doc

    my $doc = $self->doc;

Readonly accessor.
Returns instance of XML::LibXML::Element, representing the root node of the
document and everything in it.
=cut

sub doc { return $_[0]->{HI_doc} }

=head2 xpc

    my $xpath_context = $self->xpc

Readonly accessor.
Returns instance of XML::LibXML::XPathContext, representing the XPATH context
with attached root node of the document and everything in it. Using find,
findvalue and L<XML::LibXML::XPathContext/findnodes> is slightly faster than
C<$doc-E<gt>findnodes($xpath_expression)>.
=cut

sub xpc { return $_[0]->{HI_xpc} }

=head2 prefix2ns

Readonly static accessor.
Retuns the corresponding namespace for a prefix.

    my $ns = $self->prefix2ns('og'); # https://ogp.me/ns#
    my $ns = HTML::Inspect->prefix2ns('og'); # https://ogp.me/ns#
    my $ns = HTML::Inspect->prefix2ns('video'); #https://ogp.me/ns/video# 
=cut


sub prefix2ns ($self, $prefix) {
# Default and known namespaces for collectOpenGraph() when we have a document
# with no explicitly defined prefix(namespace), but then in the document it is
# used. These cases are very common.
    state %PREFIXES = (
        fb      => 'https://ogp.me/ns/fb#',
        og      => 'https://ogp.me/ns#',
        image   => 'https://ogp.me/ns/image#',
        music   => 'https://ogp.me/ns/music#',
        video   => 'https://ogp.me/ns/video#',
        article => 'https://ogp.me/ns/article#',
        book    => 'https://ogp.me/ns/book#',
        profile => 'https://ogp.me/ns/profile#',
        # From https://ogp.me/ : "No additional properties other than the basic
        # ones. Any non-marked up webpage should be treated as og:type website."
        website => 'https://ogp.me/ns/website#',
    );

    return $PREFIXES{$prefix};
}

=head2 requestURI

    my $uri = $self->requestURI;

Readonly accessor.
The L<URI> object which represents the C<request_uri> parameter which was
passed as default base for relative links to C<new()>.
=cut

sub requestURI { return $_[0]->{HI_request_uri} }

=head2 base

    my $uri = $self->base;

Readonly accessor.
The base URI, which is used for relative links in the page.  This is the
C<requestURI> unless the HTML contains a C<< <base href> >> declaration.  The
base URI is normalized.
=cut

sub base { return $_[0]->{HI_base} }

#-------------------------

=head1 Collecting

=head2 collectMeta 

    my $hash = $html->collectMeta(%options);

Returns a HASH reference with all <meta> information of traditional content:
each value will only appear once. OpenGraph meta-data records use attribute
'property', and are ignored here.

Example:

    { 'http-equiv' => { 'content-type' => 'text/plain' }
        charset => 'UTF-8',
        name => { author => 'John Smith' , description => 'The John Smith\'s page.'}
    }

=head2 collectReferences 

    $hash = $self->collectReferences;

Collects all references from document. Returns a HASH reference with
keys like C<$tag_$attr> and values an ARRAY of unique URIs found in such
tags and attributes. The URIs are in their textual order in the document,
where only the first encounter is recorded.
=cut

sub collectReferences($self) {
    return $self->{HI_refs} if $self->{HI_refs};
    my $base = $self->base;

    my %refs;
    while (my ($tag, $attr) = each %referencing_attributes) {
        my @attr = uniq map { URI->new_abs($_->getAttribute($attr), $base)->canonical }
          $self->xpc->findnodes($X_REF_ATTRS{"${tag}_$attr"});
        $refs{"${tag}_$attr"} = \@attr if @attr;
    }

    return $self->{HI_refs} = \%refs;
}

=head2 collectLinks 

    $hash = $self->collectLinks;

Collect all C<< <link> >> relations from the document.  The returned HASH
contains the relation (the C<rel> attribute, required) to an ARRAY of
link elements with that value.  The ARRAY elements are HASHes of all
attributes of the link and and all lower-cased.  The added C<href_uri>
key will be a normalized, absolute translation of the C<href> attribute.
=cut

sub collectLinks($self) {
    return $self->{HI_links} if $self->{HI_links};
    my $base = $self->base;

    my %links;
    foreach my $link ($self->xpc->findnodes($X_LINK_REL)) {
        my %attrs = map { $_->name => $_->value } grep { $_->isa('XML::LibXML::Attr') } $link->attributes;
        $attrs{href_uri} = URI->new_abs($attrs{href}, $base)->canonical if $attrs{href};
        push @{$links{$attrs{rel}}}, \%attrs;
    }

    return $self->{HI_links} = \%links;
}

=head2 collectOpenGraph

    my $hash = $self->collectOpenGraph();

Collects all meta elements which have an attribute C<property>.  See
t/12_collect_opengraph.t for examples of the HASH reference structure which is
returned. 

Example

    my $html = slurp("$Bin/data/open-graph-protocol-examples/article-offset.html");
    my $i    = HTML::Inspect->new(request_uri => 'http://example.com/article-offset.html', html_ref => \$html);
    my $og   = $i->collectOpenGraph();
    
   # {
   #   'https://ogp.me/ns#' => {
   #     'image' => [
   #       {
   #         'height' => '50',
   #         'secure_url' => 'https://d72cgtgi6hvvl.cloudfront.net/media/images/50.png',
   #         'type' => 'image/png',
   #         'url' => 'http://examples.opengraphprotocol.us/media/images/50.png',
   #         'width' => '50'
   #       }
   #     ],
   #     'locale' => 'en_US',
   #     'site_name' => 'Open Graph protocol examples',
   #     'title' => 'John Doe profile page',
   #     'type' => 'profile',
   #     'url' => 'http://examples.opengraphprotocol.us/profile.html'
   #   },
   #   'https://ogp.me/ns/profile#' => {
   #     'first_name' => 'John',
   #     'gender' => 'male',
   #     'last_name' => 'Doe',
   #     'username' => 'johndoe'
   #   }
   # }

=head1 SEE ALSO

L<URI>, L<XML::LibXML>, L<Log::Report>

=head1 AUTHORS and COPYRIGHT
    
    Mark Overmeer
    CPAN ID: MARKOV
    markov at cpan dot org
    https://solutions.overmeer.net/

    Красимир Беров
    CPAN ID: BEROV
    berov на cpan точка org
    https://studio-berov.eu

This is free software, licensed under:

The Artistic License 2.0 (GPL Compatible)

The full text of the license can be found in the LICENSE file included with
this module.

This distribution contains other free software  and content which belongs to
their respective authors.
=cut

1;
